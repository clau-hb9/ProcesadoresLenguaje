package lex.generado;
import lex.manual.SimbolosTerminales; 
import lex.manual.Symbol;

%%


%class Lexer
%implements SimbolosTerminales
%public
%unicode

%line 	/*Cuenta las lineas. yyline devuelve las lineas desde principio hasta token*/
%column /*Columnas. yycolumn*/
%char 	/*Cuenta los caracteres. yychar te devuelve el numero de caracteres contados desde el principio hasta donde este el token*/

%function next_token 	/*Nombre del metodo que escanea la entrada y devuelve el siguiente token*/
%type Symbol 			/*Tipo de retorno para la funcion scan*/

/*Valores y codigo que se va a ejecutar cuando se llegue al final del fichero*/
%eofval{
    return new Symbol(EOF);
%eofval}


/*MACROS Y EXPRESIONES REGULARES*/
Newline    = \r | \n | \r\n
Whitespace = [ \t\f] | {Newline}
Integer		= [0-9]+


/* Comentarios */
Comment = {TraditionalComment} | {EndOfLineComment}
TraditionalComment = "/*" {CommentContent} \*+ "/"
EndOfLineComment = "//" [^\r\n]* {Newline}
CommentContent = ( [^*] | \*+[^*/] )*

ident = ([:jletter:] | "_" ) ([:jletterdigit:] | [:jletter:] | "_" )*




%state CODESEG

%%  

/* REGLAS PARA DETERTAR TOKENS Y ACCIONES ASOCIADAS */
<YYINITIAL> {

  {Whitespace} {                              }
  {Comment} {                              }
  ";"          { return new Symbol(sym.SEMI); }
  "+"          { return new Symbol(sym.PLUS); }
  "-"          { return new Symbol(sym.MINUS); }
  "*"          { return new Symbol(sym.TIMES); }
  "n"          { return new Symbol(sym.UMINUS); }
  "("          { return new Symbol(sym.LPAREN); }
  ")"          { return new Symbol(sym.RPAREN); }
{Integer}      { return new Symbol(sym.NUMBER ,Integer.parseInt(yytext())); 					}

}



// error fallback
.|\n          {System.err.println("warning: Unrecognized character '"+ yytext()+"' -- ignored" + " at : "+ (yyline+1) + " " + (yycolumn+1) + " " + yychar); }

